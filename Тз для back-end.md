### **Подробное описание бэкенд-части для сервиса документов**  
**Стек**: Flask (Python) + PostgreSQL (база данных) + SQLAlchemy (ORM).  
**Цель**: Создать серверную часть, которая обрабатывает запросы от фронтенда, управляет данными и обеспечивает безопасность.  

---

### **1. Общая архитектура бэкенда**  
Сервер состоит из:  
1. **API-эндпоинтов** (маршруты для обработки запросов).  
2. **Моделей данных** (таблицы в базе данных).  
3. **Сервисных слоев** (логика обработки данных, интеграции со сторонними сервисами).  
4. **Системы аутентификации** (регистрация, вход, управление правами).  

---

### **2. Основные сущности (таблицы в базе данных)**  

#### **2.1. Пользователь (User)**  
**Атрибуты**:  
- **id** — уникальный идентификатор (автоинкрементное число или UUID).  
- **email** — электронная почта (уникальная, обязательная).  
- **phone** — номер телефона (уникальный, опциональный).  
- **password_hash** — зашифрованный пароль.  
- **full_name** — полное имя пользователя.  
- **is_active** — статус аккаунта (активен/заблокирован).  
- **created_at** — дата регистрации.  

**Связи**:  
- Один пользователь может принадлежать к нескольким предприятиям (через таблицу `UserEnterprise`).  
- Один пользователь может иметь несколько ролей в разных отделах (через таблицу `UserRole`).  

---

#### **2.2. Предприятие (Enterprise)**  
**Атрибуты**:  
- **id** — уникальный идентификатор.  
- **name** — название предприятия (обязательное).  
- **inn** — ИНН (уникальный, обязательный).  
- **logo_url** — ссылка на логотип.  
- **created_by** — ID пользователя, создавшего предприятие.  

**Связи**:  
- У предприятия есть множество отделов (`Department`).  
- У предприятия есть множество пользователей (через `UserEnterprise`).  

---

#### **2.3. Отдел (Department)**  
**Атрибуты**:  
- **id** — уникальный идентификатор.  
- **name** — название отдела (уникальное в рамках предприятия).  
- **code** — короткий код (например, "HR", уникальный в рамках предприятия).  
- **parent_id** — ID родительского отдела (для иерархии).  
- **enterprise_id** — ID предприятия, к которому относится отдел.  
- **manager_id** — ID руководителя отдела (ссылка на `User`).  
- **is_active** — статус (активен/архивирован).  

**Связи**:  
- Отдел может иметь подотделы (через `parent_id`).  
- В отделе может быть несколько сотрудников с разными ролями.  

---

#### **2.4. Документ (Document)**  
**Атрибуты**:  
- **id** — уникальный идентификатор.  
- **title** — название документа.  
- **file_url** — ссылка на файл в облачном хранилище (например, AWS S3).  
- **status** — статус: "черновик", "на подписи", "подписан", "отклонен".  
- **deadline** — срок подписания.  
- **creator_id** — ID пользователя, создавшего документ.  
- **created_at** — дата создания.  

**Связи**:  
- Документ может быть связан с несколькими отделами или пользователями (через таблицу `DocumentRecipient`).  
- У документа есть история подписаний (таблица `DocumentHistory`).  

---

#### **2.5. Дополнительные таблицы**  
- **UserRole** — связи пользователей с ролями в отделах (например, "Подписант", "Администратор").  
- **DocumentRecipient** — связи документов с получателями (пользователями или отделами).  
- **DocumentHistory** — история действий с документом (кто подписал, когда, комментарии).  
- **Notification** — уведомления для пользователей (текст, тип, статус прочтения).  

---

### **3. API-эндпоинты (маршруты)**  

#### **3.1. Аутентификация и регистрация**  
- **POST /api/auth/register** — регистрация нового пользователя.  
  - Принимает: email, пароль, имя.  
  - Действие: проверяет уникальность email, хеширует пароль, сохраняет пользователя в БД.  
- **POST /api/auth/login** — вход в систему.  
  - Принимает: email/телефон, пароль.  
  - Действие: проверяет пароль, возвращает JWT-токен для доступа к API.  
- **POST /api/auth/refresh** — обновление JWT-токена.  

#### **3.2. Управление предприятиями**  
- **POST /api/enterprises** — создание предприятия (только для авторизованных пользователей).  
  - Принимает: название, ИНН, логотип (файл).  
- **GET /api/enterprises** — список предприятий пользователя.  
- **PUT /api/enterprises/{id}** — обновление данных предприятия (только для создателя).  

#### **3.3. Управление отделами**  
- **POST /api/departments** — создание отдела.  
  - Принимает: название, код, ID родительского отдела, ID предприятия.  
  - Действие: проверяет уникальность названия и кода в рамках предприятия.  
- **GET /api/departments** — список отделов предприятия.  
- **GET /api/departments/{id}/tree** — древовидная структура отделов.  

#### **3.4. Работа с документами**  
- **POST /api/documents** — загрузка документа.  
  - Принимает: файл, список получателей (ID пользователей или отделов), срок подписания.  
  - Действие: сохраняет файл в облачное хранилище, создает записи в `Document` и `DocumentRecipient`.  
- **POST /api/documents/{id}/sign** — подписание документа.  
  - Принимает: код подтверждения из SMS/email.  
  - Действие: обновляет статус документа и добавляет запись в `DocumentHistory`.  
- **GET /api/documents** — список документов пользователя (с фильтрами по статусу, дате).  

#### **3.5. Уведомления**  
- **GET /api/notifications** — список непрочитанных уведомлений.  
- **PUT /api/notifications/{id}/read** — отметка уведомления как прочитанного.  

---

### **4. Безопасность**  

#### **4.1. Аутентификация**  
- Используется JWT (JSON Web Token).  
- Токен передается в заголовке `Authorization: Bearer {token}`.  
- Срок жизни токена: 15 минут (для обновления используется refresh-токен).  

#### **4.2. Шифрование**  
- Пароли хранятся в виде хешей (алгоритм bcrypt).  
- Конфиденциальные данные (например, телефон) шифруются в БД (AES-256).  

#### **4.3. Защита от атак**  
- **SQL-инъекции**: Используйте ORM (SQLAlchemy) для построения запросов.  
- **XSS**: Экранируйте пользовательский ввод при выводе данных.  
- **CSRF**: Для веб-форм добавляйте CSRF-токены (в API обычно не требуется).  

---

### **5. Работа с базой данных**  

#### **5.1. Миграции**  
- Используйте инструмент **Alembic** для управления изменениями схемы БД.  
- Примеры миграций:  
  1. Создание таблицы `User`.  
  2. Добавление поля `is_active` в таблицу `Department`.  

#### **5.2. Индексы**  
- Добавьте индексы на часто используемые поля:  
  - `User.email` (для быстрого поиска при входе).  
  - `Document.deadline` (для фильтрации просроченных документов).  

#### **5.3. Резервное копирование**  
- Настройте автоматическое ежедневное резервное копирование БД (например, через pg_dump).  

---

### **6. Интеграции со сторонними сервисами**  

#### **6.1. Отправка SMS**  
- Используйте API Twilio или smsc.ru.  
- **Сценарий**: При подписании документа пользователь получает SMS с кодом подтверждения.  

#### **6.2. Отправка email**  
- Используйте SendGrid или Mailgun.  
- **Сценарий**: Уведомление о новом документе на подпись.  

#### **6.3. Хранение файлов**  
- Загружайте документы в облачное хранилище (AWS S3, MinIO).  
- **Сценарий**: Пользователь загружает PDF-файл → сервер сохраняет его в S3 → в БД записывается ссылка на файл.  

---

### **7. Обработка ошибок**  
- Возвращайте понятные HTTP-статусы:  
  - **200 OK** — успешный запрос.  
  - **400 Bad Request** — неверные данные (например, некорректный email).  
  - **401 Unauthorized** — пользователь не авторизован.  
  - **404 Not Found** — документ или отдел не существует.  
  - **500 Internal Server Error** — ошибка на сервере (логируйте такие случаи!).  

- Формат ответа при ошибке:  
  ```json
  {
    "error": "Invalid email",
    "details": "Email должен содержать символ @"
  }
  ```

---

### **8. Рекомендации по разработке**  

#### **8.1. Разделение задач между разработчиками**  
- **Разработчик 1**:  
  - Модели данных (`User`, `Enterprise`, `Department`).  
  - Аутентификация и авторизация.  
  - API для управления предприятиями и отделами.  
- **Разработчик 2**:  
  - Модели данных (`Document`, `DocumentHistory`).  
  - API для работы с документами.  
  - Интеграции (SMS, email, облачное хранилище).  

#### **8.2. Тестирование**  
1. **Юнит-тесты**: Проверяйте отдельные функции (например, хеширование пароля).  
2. **Интеграционные тесты**: Тестируйте API-эндпоинты (например, создание документа).  
3. **Ручное тестирование**:  
   - Проверьте сценарий:  
     - Пользователь регистрируется → создает предприятие → добавляет отдел → отправляет документ.  

#### **8.3. Документация**  
- Напишите Swagger-документацию для API (используйте **flasgger**).  
- Создайте файл `README.md` с инструкцией по запуску проекта.  

#### **8.4. Логирование**  
- Записывайте ошибки в файл `errors.log`.  
- Логируйте важные события:  
  - Успешный вход пользователя.  
  - Создание документа.  
  - Ошибка при подписании.  

---

### **9. Развертывание (деплой)**  
1. **Локальная разработка**:  
   - Установите PostgreSQL и Flask.  
   - Запустите сервер командой `flask run`.  
2. **Прод (production)**:  
   - Используйте **Gunicorn** или **uWSGI** для запуска Flask.  
   - Настройте Nginx как обратный прокси.  
   - Разверните на облачной платформе (AWS EC2, Heroku).  

---

### **10. Пример сценария работы**  
1. Пользователь регистрируется через `/api/auth/register`.  
2. Создает предприятие через `/api/enterprises`.  
3. Добавляет отдел "Бухгалтерия" через `/api/departments`.  
4. Загружает документ через `/api/documents`.  
5. Система отправляет уведомления получателям.  
6. Получатели подписывают документ через `/api/documents/{id}/sign`.  

---

Это описание поможет разработчикам понять, как взаимодействуют компоненты сервера, и распределить задачи. Начните с проектирования моделей данных и простых эндпоинтов (регистрация, создание предприятия), затем переходите к сложной логике (документы, уведомления).
